#+begin_export latex
\renewcommand{\contentsname}{Table des matières}
\clearpage \tableofcontents \clearpage
#+end_export

* Introduction

** Objectif du document

   L'objectif du document est de présenter les choix et la conception détaillée de l'application *Fitness Tracker*
   en réponse au cahier des charges précédemment établi. Ainsi que présenter certaines solutions
   techniques aux problèmes rencontrés pendant le développement.

** Rappel du projet

   Le projet vise à développer une application de suivi de bien-être
   et sportif. Les principales fonctionnalités consistent à rentrer des
   données de nutrition, ou d'autres données relatives aux sport
   et de suivre l'évolution de certaines tendances dans le temps.

   L'application doit être multi-platforme. Elle est composée à
   la fois d'un /frontend/, application web hybride et un /backend/,
   Une /API/ est chargée de faire la communication entre les deux éléments.

** Environnement de développement

   | Réalisation               | Outils                                                             |
   |---------------------------+--------------------------------------------------------------------|
   | Application serveur       | ~Python 3.11~;                                                     |
   |                           | ~FastAPI 0.110~, un /framework/ web specialisé dans la création d'/API/; |
   |                           | ~mypy 1.9~, un outil de typage statique pour Python;               |
   |---------------------------+--------------------------------------------------------------------|
   | Application mobile et web | ~Ionic/React~, un /framework/ de création d'interface mobile utilisant |
   |                           | la bibliothèque ~React~ comme moteur d'interface graphique;        |
   |                           | ~Capacitor~, un environnement d'exécution permettant d'utiliser    |
   |                           | les applications web comme des applications mobiles natives,       |
   |                           | ~Capacitor~ est un successeur de ~Cordova~ et ~PhoneGap~.;         |
   |                           | Et inclut des plugins pour des applications natives comme          |
   |                           | la lecture de code bar.                                            |
   |                           | ~Redux~, ~Redux-Toolkit~ et ~RTK-Query~, des outils de             |
   |                           | gestion d'état global de l'application.                            |
   |---------------------------+--------------------------------------------------------------------|
   | Applications natives      | ~Android Studio~ pour la partie ~Android~;                         |
   |                           | De véritables smartphones android vont être utilisés               |
   |                           | durant le développement. Egalement, utilisation des émulateurs     |
   |                           | présents dans les environnements de développements natifs.         |
   |---------------------------+--------------------------------------------------------------------|
   | Gestion de développement  | ~Git~ pour le developpement et ~Github~ pour l'hébergement du      |
   |                           | code, ainsi que les pipelines de vérification.                     |
   |---------------------------+--------------------------------------------------------------------|
   | Gestion de projet         | ~Trello~ un outil de gestion de projet de type "board kanban"      |
   |---------------------------+--------------------------------------------------------------------|
   | Redaction de documents    | ~Latex~ et ~vim~, en utilisant un plugin ~Orgmode~ et ~pandoc~     |
   |                           | pour la réalisation du document final (pdf)                        |
   |---------------------------+--------------------------------------------------------------------|
   | Redaction de diagrammes   | ~diagrams.net~ un outil en ligne de réalisation de        |
   | UML                       | diagrammes                                                         |
   |---------------------------+--------------------------------------------------------------------|

* Vue d'ensemble de l'architecture

L'application est séparée en 3 parties distinctes. L'/architecture système/ concerne
les logiciels et matériels (ou matériels virtuels) nécessaires à l'hébergement et
à la mise en production de l'application.
Le /backend/ constitue la partie logique de l'application ainsi que la persistence des
données utilisateur. Le /frontend/ est quant à lui responsable de l'interface homme machine
permettant la réalisation des différentes taches de l'application.

Une telle architecture peut être considérée comme un /Saas/, car l'application n'a pas
besoin d'être installée pour que l'utilisateur ait la capacité de l'utiliser (dans sa version webapp),
la version mobile du frontend ne servant qu'a accéder à certaines fonctionnalités non essentielles au
fonctionnement et à améliorer les peformances[fn:: il n'y a pas besoin de télécharger le fichier js à chaque fois
que l'on accède à l'application mobile].
Comme la persistence des données est au niveau du /backend/, non accessible à l'utilisateur,
le développeur est responsable de la maintenance et de l'exploitation des données sur l'application.

** Architecture système et déploiement

   L'application est aujourd'hui déployée dans sa majorité sur un serveur virtuel ~AWS EC2~.
   Les composants de l'architecture système sont les suivant:

#+CAPTION: Architecture système
#+ATTR_HTML: :width 300px
   [[./img/architecture_systeme.png]]

   1. ~Mongo DB~ : Une base de donnée /NoSQL/ orientée document. Toutes les donneés de l'application y sont stockées;
   2. ~Firebase~ : Un service utilisé pour les notifications push, utilise le ~Firebase Cloud Messaging~ (~FCM~);
   3. ~Amazon EC2~ : Un service de serveur virtuel fonctionnant sur la distribution Linux ~Amazon Linux 2~.
      Est utilisé pour lancer des /containers/ ~Docker~;
   4. ~Amazon S3~ : Un service de stockage de fichier statique et d'hébergement de ces fichiers. Héberge l'application
      web (un fichier ~index.html~ et un fichier ~index.js~)
   5. ~Docker~ : Logiciel de /containerisation/ de l'application, est utilisé pour configurer et stocker les environnements
      nécessaires à l'installation de l'application /backend/.
   6. ~Docker compose~ : Décrit les interactions entre les différents /containers/ ainsi que les interactions avec
      l'exterieur des /containers/, comme le stockage ou les ports réseaux.

** Backend

   L'application ~backend~ est constituée de plusieurs éléments. Outre ceux déjà présentés,
   celle-ci comprends:

#+CAPTION: Architecture backend
#+ATTR_HTML: :width 300px
   [[./img/architecture_backend.png]]

   1. ~FastAPI~: un framework web ~Python~, centré sur des fonctionnalités de validation d'entrée typées et
      de sérialisation/désérialisation.
   2. ~Uvicorn~ : Un serveur ASGI (~Asynchronus Server Gateway interface~) qui agit comme un environnement
      d'execution asynchrone et web pour ~Python~. Ce serveur permet donc de faire fonctionner l'application ~Python~
      en mode asynchrone.
   3. Une architecture en couche, inspirée par ~Clean Architecture~:
      Il y a une couche ~Domaine~, qui décrit les ~Entitées~ et ~Aggregats~ du systême, une couche ~Infrastrucutre~,
      utilisée pour les implémentations comme le stockage du reste de l'application.
      Une couche de ~Presentation~ qui permet de communiquer avec l'extérieur, ainsi qu'une couche ~Application~ (ou Service)
      qui s'occupe de l'orchestration entre les autres élements de l'application. Nous détaillons cette architecture
      dans la suite du document.


** Frontend (application hybride)

   L'application ~frontend~ comprends quant à elle ces éléments:

#+CAPTION: Architecture frontend
#+ATTR_HTML: :height 300px
   [[./img/architecture_frontend.png]]

   1. ~React~: Une bibliothèque de rendu "réactive". Permet de créer des interfaces graphiques complexes en ~HTMl~ et ~typescript~.
      Est également utilisée comme une couche d'abstraction au dessus d'~HTML~, grace au ~JSX~.
      Est aussi à la base d'un écosystèmes de bibliothèques.
   2. ~Redux~: Une bibliothèque qui permet d'utiliser le pattern ~Flux~ (une variation du pattern MVC[fn:: https://facebookarchive.github.io/flux/docs/in-depth-overview/]) pour gèrer l'état de l'application.
      L'état ainsi stocké dans ~Redux~ permet de rendre l'application plus prédictible car celui-ci est centralisé mis à jour et utilisé
      par un flux unidirectionnel. Nous détaillons ce point dans la suite du document.
   4. ~RTK-Query~: Un moteur de requète ~AJAX~ compatible avec ~Redux~. Gère le cache et l'invalidation de cache, ainsi que les états
      des requètes ("pending", "error" ,"loading" etc.)
   4. ~Ionic~: A la fois une bibliothèque graphique de composants ~React~ répliquant le visuel des composants natif ~Android~ et ~Ios~ et
      une abstraction pour effectuer certaines tâches liées à ~Capacitor~ (~inoic cli~)
   5. ~Capacitor~: Fournit une abstraction entre les composants ~Ionic~ et les applications natives ~Ios~ et ~Android~. Permet également
      d'utiliser des fonctionnalités natives des téléphones normalement inaccessibles à une application web. Certains plugins permettent
      notamment d'utiliser le /GPS/ du téléphone, ou encore les fonctionnalités de stockage.

* Conception
** Concepts généraux

*** SOLID

Les principes /SOLID/ contribuent de manière significative à l’élaboration
de logiciels modulaires, évolutifs et maintenables.

Dans le cadre de notre programme, l'application de ces principes
nous a aidé à la mise en place de test unitaire grâce à *D*, l'injection de dépendance,
qui permet de modifier une base de donnée en une version /in memory/
permettant des tests rapides. Ou encore de tester en isolation les
services et le domaine.

De la même façon le *S*, principe de responsabilité unique (/Separation of concern/), nous donne
une ligne directrice dans l'élaboration des différentes classes utilisées
dans notre programme. En effet, l'application de ce principe permet
une architecture plus modulaire, car la responsabilité unique implique
qu'une classe "n'ait qu'une seule raison de changer"[fn:: Martin, Robert C. (2003). Agile Software Development, Principles, Patterns, and Practices. . p. 95].
Cela permet de garantir la réutilisation et la modularité du code
en diminuant l'interdépendance entre les classes:
si une classe n'a qu'une raison de changer, alors, modifier une classe
revient à modifier une fonctionnalité. Chaque classe ayant un rôle
précis dans l'application.

Les 3 autres principes ont été moins utilisés durant l'élaboration
du programme.

Tout d'abord, *L*, le principe de substitution de Liskov est garanti
par le caractère dynamique des classes. ~Mypy~, le logiciel de vérification
de type statique de ~Python~ ne permet pas de créer des classes qui transgresserait
ce principe[fn:: https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides].
Nous pouvons cependant noter que celui-ci apparait uniquement dans le cadre
de l'héritage, et qu'il n'y en a pas dans notre programme.

Les principes *O* Ouvert/fermé et *I*, Ségragation des interfaces, ne
sont que peu utilisés. Ces principes s'imposent
lorsque la base de code devient plus importante, en effet il n'y a que
peu d'interfaces, et l'unique utilisation du principe *O* est dans
l'élaboration des /Entries/ génériques. Nous en parlerons plus loin.

*** Inspiration REST

/REST/ (/REpresentational State Transfer/) est un style d'architecture visant
à simplifier la communication client serveur en assignant une /URI/ (/Unique Ressource Identifier/)
à chaque ressource, et à utiliser les verbes ~HTTP~ pour signifier l'intention
du client par rapport à ces ressources. Le serveur doit quant à lui utiliser les codes
de retour ~HTTP~ pour signifier l'état du traitement de la demande du client.
Aussi une architecture /REST/ doit être "découvrable" (/discoverable/).
C'est à dire qu'un client doit avoir connaissance facilement du reste de l'application
à partir d'une première requète. Grâce à l'utilisation d'hyperliens par exemple.
Dans notre cas, le /backend/ agit comme le serveur et le /frontend/ comme le client.

Notons que /REST/ n'est pas une norme, mais plutôt une série de principes.

Le but de ce style d'architecture est de garantir une commmunication /stateless/, "sans état", entre
le client et le serveur. C'est à dire que ni le client, ni le serveur n'ont besoin de conserver
un état sur l'un ou l'autre pour communiquer. Il y a notamment la garantie que le client
accèdera toujours à la même ressource via la même /URI/.

Nous n'allons pas utiliser totalement le style d'architecture /REST/, mais se concentrer
seulement sur les /URI/ et les verbes et code de retour ~HTTP~, car, dans le cadre d'une /API/ les autres notions
sont peut généralement peu utile et en pratique peut utilisées, au grand désarroi de l'auteur[fn:: https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven].

Pour garantir ces principes, nous avons besoin de plusieurs choses:

1. Des identifiants uniques par ressource (/URI/). Nous utiliserons les /UUID4/, qui est un format d'identifiant unique généré aléatoirement.
   La version 4 est privilégiée car elle utilise un générateur de nombre aléatoire plutôt que des caractéristiques du serveur
   (comme son adresse MAC[fn:: https://datatracker.ietf.org/doc/html/rfc4122, voir la section "Identifier uniqueness considerations"])
2. Les verbes ~HTTP~ doivent correspondre à des actions précises:

   - *GET* permet de lister ou obtenir une ou des ressources
   - *POST* permet de créer une ressource
   - *PUT* permet de modifier une ressource
   - *DELETE* permet de supprimer une ressource

   Nous avons décidé de ne pas utiliser *PATCH*, car, bien qu'il soit défini comme un moyen de modifier une partie d'une ressource,
   il implique également que le client ait connaissance de la manière dont sont considérées les parties non transmises dans la requête *PATCH*. Cela peut porter
   à confusion, notamment quand certains champs de la ressource sont optionnels.

3. Les actions doivent donner lieu à des opérations et des retours serveurs non-ambigus.
   Par exemple, la création d'une ressource ne doit pas retourner directement le contenu de la ressource créée mais
   uniquement l'/URI/ de la nouvelle donnée créée. A la fois pour des raisons de performance, et de séparation
   de responsabilité: un *POST* ne doit pas retourner les données à la manière d'un *GET*.

Nous verrons le détail les différents /endpoints/ de l'/API/ dans la suite du document.

** Backend

Le backend est un programme ~Python~ consistué de plusieurs modules : ~authentication~, ~commons~, ~debug~, ~entry~, ~food~,
~notification~, ~report~ et ~user~.
Le tout créé un système de gestion de données nutritives et de bien-être complet.

*** Choix des bibliothèques
**** ~Python~
Le choix de ~Python~ comme language de programmation a été motivé par plusieurs points.
La première idée était d'utiliser des bibliothèques de /machine learning/ et /data science/
comme ~Panda~ et ~Scikit-learn~ pour créer une fonctionnalité de mesure automatique de calories
à partir de photographies. ces bibliothèques sont disponible en ~Python~, et les documentations
en ligne sur ce genre de sujet utilisent surtout ce langage. ~Python~ étant un des langages les plus utilisés en /data science/[fn:: https://www.dasca.org/world-of-data-science/article/which-programming-language-is-ideal-for-data-science-python-or-r ]
Cependant il s'est trouvé que la quantité et la qualité des
données requises pour une telle tâche n'a pas permit d'aboutir à un résultat pour le moment.

~Python~ offre cependant certains avantages par rapport à d'autres languages.
Comme c'est un langage interprété, le déploiement ne demande pas de phase de compilation.

Un certain nombre de fonctionalitéds du langage simplifient aussi le développement
comme par exemple les décorateurs[fn:: une version "statique" du pattern décorateur, que l'on
peut implémenter à l'aide des annotations en ~Java~ par exemple.] ou
son caractère multi-paradigme : à la fois orienté objet[fn:: avec des classes "simples" ou des "dataclasses",
qui ont sont l'équivalent ~Python~ des ~records~ en ~Java~ ou ~C#~.],
fonctionnel[fn:: en ~Python~, les fonctions sont considérés comme des "citoyens de premiere classe", on peut
donc les utiliser comme des valeurs, et les passer en paramètre. De plus, la bibliothèque standard propose
des fonctionalités typique d'un language fonctionnel comme des fonctions ~map~, ~filter~, ~reduce~, ~zip~, ~takewhile~...
On peut également créer des listes en intention à la manière d'~Haskell~, ou encore faire de l'/itération paresseuse/ grâce aux ~generateurs~ ]
et impératif.
Les bibliothèques utilisés dans le projets fonctionnent constamment à travers cette approche multi-paradigme.

La notion de typage optionel et incremental[fn:: https://peps.python.org/pep-0484/] permet de faciliter
le développement tout en garantissant un sécurité des types (à l'inverse des langages dynamiques classiques).
Le /Structural duck typing/, notion propre à ~Python~, remplace la notion d'interface dans un contexte de typage dynamique[fn:: https://peps.python.org/pep-0544/]

Enfin, l'écosystème est adapté au developpement web incremental et rapide. De nombreuses bibliothèques et /frameworks/ existent
pour nous aider à développer une /API/. Et il nous a semblé que ~Python~ privilégiait une approche "bibliothèque" plutôt qu'une
approche "/framework/", ce qui permet de tester des /design patterns/ qui n'auraient pas été prévu
par tel ou tel /framework/.


**** FastAPI
Nous avons choisi ~FastAPI~ comme /framework/ web principal.
Il est léger et spécialisé : il été conçu uniquement pour
la création d'/API/, à l'inverse de la plupart des autres /frameworks/
web qui proposent des écosystèmes logiciels complets (allant parfois
du déploiement jusqu'au style de page[fn:: Par exemple ASP.NET]).

~FastAPI~ inclu une validation des données et une serialisation/désérialisation par typage fort
en utilisant la librairie ~Pydantic~. Ainsi, nous pouvons garantir que les entrées et sorties
de l'application sont typés, évitant ainsi une classe entière d'erreurs.
Nous avons aussi utilisé le système d'injection de dépendance intégré, les middleware,
ainsi que les abstractions au dessus de systèmes d'authentification comme ~OAuth2~.
Enfin, ~FastAPI~ génère automatiquement une documentation ~OpenAPI~, ce qui faisait
parti de nos exigences fonctionnelles.

**** Mypy

~Mypy~ est un système de vérification statique de typage en ~Python~.
Il permet de s'assurer de la cohérence des types de l'application sans la lancer.
Par exemple, ~Mypy~ peut déterminer si une fonction qui retourne un ~int~, retourne, en
effet un ~int~. ~Mypy~ fonctionne de concert avec ~FastAPI~ et ~Pydantic~.

**** Autre bibliothèques

Nous utilisons d'autres dépendances dans le projets:

- ~requests~, un client ~HTTP~ pour permettre au serveur d'effectuer des requètes
- ~py-jwt~, une bibliothèque d'encodage et décodage des tokens ~JWT~ (a voir dans la suite du document)
- ~pymongo~, un driver ~MongoDB~ pour ~Python~, qui permet de connecter la base de donnée à l'application
- ~isort~ et ~black~, des outils pour formatter le code de façon standard[fn:: https://peps.python.org/pep-0008/]
- ~pytest~ et ~coverage~, des bibliothèques de test unitaire et de controle de couverture de tests.
- d'autres bibliothèques auxilliaires pour quelques fonctionnalités optionnelles de ~Pydantic~ et l'accès à ~Firebase~.

*** Clean Architecture

Le /backend/ été conçu en suivant les principes de la /Clean Architecure/. C'est
une des différentes façons d'implémenter /SOLID/ dans un context d'application utilisateur (par opposition à une bibliothèque).
Le principe est de séparer l'application en plusieurs couches distinctes et indépendantes, et de ne permettre qu'un petit ensemble de
communication entre ces couches. Cette structure permet d'isoler la logique métier des interfaces utilisateurs et des infrastructures.

Concrètement, /Clean Architecture/ défini 4 couches: /Domaine/, /Présentation/, /Application/, /Infrastructure/, ayant
chacune un rôle distinct.

- La couche /Domaine/ contient les /Entitées/ et /Aggregats/, soit, les objets domaine de l'application. Dans notre cas,
  un /User/ ou encore une nourriture (/Food/) est une /Entitité/.
  Ce sont des classes "simples", sans référence à la base de donnée où à quelconque technologie ou entrée/sortie particulière.

- La couche /Présentation/ est dédiée à l'interface entre l'application et l'extérieur. Il s'agit dans notre cas de
  la partie de l'application qui s'occupe des /Contrats/ des requètes et réponses ~HTTP~ (leur format) ainsi que les
  règles de validation associées. C'est la seule couche de l'application qui fait directement référence à ~FastAPI~.

- La couche /Application/ ou /Service/ a pour fonction de décrire des opérations concrètes sur les /Entitées/, et de
  faire le lien entre plusieurs couches. Par exemple, c'est cette couche qui détermine si telle action doit utiliser
  telle méthode d'un /Repository/.
  Pour garantir une approche /SOLID/, elle ne fait pas directement référence aux implémentations, mais uniquement aux
  interfaces qui sont implémentées dans la couche /Infrastructures/.
  Les interfaces sont d'ailleurs déclarées dans la couche application.

- La couche /Infrastructure/ contient les implémentations des interfaces. Les autres couches ne font jamais de référence
  directes à cette couche. C'est un système de configuration (liée à de l'injection de dépendance) qui s'occupe
  de dispatcher la bonne implémentation pour le cas d'utilisation ou l'environnement voulu.
  Dans notre cas, la couche infrastructure implémente principalement les /Repositories/ ainsi que les méthodes d'authentification:
  La classe qui s'occupe de sérializer et désérializer les ~JWT~ en class d'authentification /AuthPassKey/, est une implémentation
  concrète de la classe /AuthFormatter/ (/JWTAuthFormatter/).

- Des classes de /Configuration/ sont également utilisées pour créer de l'injection de dépendances (soit, définir quelle implémentation
  doit implémenter telle interface dans tel contexte). D'ailleurs, la configuration n'a pas besoin de déterminer
  statiquement quelle implémentation doit être utilisé dans tel cas, mais peut utiliser une /Factory/ pour déterminer dynamiquement
  quelle classe doit être utilisée dans un cas d'utilisation précis (voir le /design pattern/ /Strategy/)

#+CAPTION: Graphe de dépendance du module /food/ de l'application
[[./img/example_clean_architecture_flow.png]]

Ici, on peut voir plusieurs avantages de la /Clean Architecture/.
Ce schéma représente un graphe de dépendance entre plusieurs élements du module /Food/, utilisé pour traiter
les demandes de l'applications par rapport à la creation, listage et suppression de nourriture.
Les flèches en pointillées représentent les dépendances entre les différentes classes et modules.

On peut voir que la couche /Domaine/, et l'entitée /Food/ ne dépendent de rien, on peut ainsi modifier
notre domaine sans avoir besoin de modifier le reste de l'application.
La couche /Application/ quant à elle, comprends le /FoodCrudService/ et le /FoodRepository/, on
peut voir que cette couche fait office d'orchestration et dépend de la couche /Domaine/.
On remarque également que la classe /FoodRepository/ est une interface, implémentée de manière
spécifique par une classe de la couche /Infrastructure/ (une classe de configuration s'occupe
de choisir la bonne implémentation).
Enfin, la couche /Présentation/ dépend uniquement de la couche /Application/. Le module /food.api/
est dépendant des classes /Requests/, qui sont les contrats utilisé pour les diverses requètes.

Une architecture comme celle-ci permet un couplage faible: la couche présentation peut changer
(on peut envisager de modifier la /Présentation/ par une interface native ou un /CLI/ par exemple),
de même l'implémentation spécifique de la base de donnée n'est pas déterminée, ce qui permet d'utiliser
l'application sans base de donnée (par exemple avec les données stockés en /RAM/ ou dans un simple fichier).
Egalement, on peut étendre la couche /Application/ (les fonctionnalités du logiciel) sans nécessairement
modifier le /Domaine/.
Enfin, les différentes parties de l'applications peuvent être testées de façon unitaire, en isolation des uns par rapport aux autres.

*** Domaine
Voici une vue d'ensemble des entitées de l'application:

#+CAPTION: Entités liées à la nourriture
[[./img/nutrition_domain.png]]

Les données liées à la nutrition sont modélisées en suivant des normes
des qualités nutritionnelles du produit[fn:: réglement ~(UE) n°1169/2011~]. Le /Serving size/
permet d'indiquer la mesure des informations nutritionnelles (généralement par 100 grammes)

#+CAPTION: Entités liées à la nourriture
[[./img/domaine_food.png]]

Une nourriture contient des informations nutritionnelles, mais également
d'autres données comme un nom, l'utilisateur qui a entré les données, ou encore
des potentiels ingrédients.

#+CAPTION: Entités liées à l'utilisateur
#+ATTR_LATEX: :scale 0.5
[[./img/domain_user.png]]

Les utilisateurs ont font également références aux
informations nutritionnelles. En effet, il est aisé d'utiliser
le même domaine pour décrire la nourriture, et, par exemple,
combien de calories un utilisateur a décidé d'ingérer par jour.

#+CAPTION: Entités liées aux entrées journal
[[./img/domain_entry.png]]

Une entité /Entry/ contient un /payload/ générique, on peut voir ici
que les différents /payloads/ sont des implémentation d'une interface /Payload/
Cela nous permettra de créer de nouveaux payloads, et de gérer tous les /payloads/
de façon générique dans l'application.

Comme nous pouvons le voir, la majorité des classes sont liés entre elles par
de la composition ou de l'aggregation.
Aussi, les différents types d'entrées sont des implémentations différents
de l'interface /Entry/, ce qui permet d'en rajouter à la volée dans l'application.
Et ainsi rendre celle-ci facilement extensible.
Le domaine étant "plat", sans notion d'héritage, la modularité est conservée au maximum.

*** Implémentations des repositories

La plupart des objets domaines sont stockés tel quels dans la base de donnée, ~MongoDB~
permettant de stocker directement des documents complexes dans un format rappelant le
~JSON~[fn:: https://www.mongodb.com/docs/manual/reference/bson-types/].

Nous pouvons noter l'utilisation de plusieurs design patterns propres aux
base de données orienté document. En effet, contrairement aux base de données ~SQL~
classiques, les base de données orienté document offre une plus grande flexibilité
dans la manière dont les données sont stockées : la notion de schéma n'existe pas,
et ces bases de données n'ont pas de contrainte d'intégrité[fn:: https://www.mongodb.com/docs/manual/data-modeling/data-consistency/].
Un principe de base pour l'élaboration d'une base de donnée orienté document
est de se baser sur les ~Access Patterns~ plutôt que sur un schéma, le
principe est de stocker les données telles qu'on veut y accéder plutôt que
de créer des requètes complexes. Même si cela implique une dénormalisation
des données.

**** Dénormalisation

Dans notre cas, la dénormalisation est aussi liée au métier:
Nous ne voulons pas qu'un utilisateur ait sont total calorique modifié si
les informations nutritionnelles d'un produit changent. Par conséquent,
les informations nutritionnelles d'une entrée sont répliquée, plutôt
que d'être liées par une /foreign key/.

**** /Extended reference/

Il n'y a pas de table /NutritionComposition/ et une autre table /Vitamin/ par exemples.
Toutes les classes aggrégées à /NutritionComposition/ sont stockées dans le même document.
En base de donnée.

**** /Bucket/

Les objets de la classe /Entry/ ne sont jamais stockés tel quels
dans la base de données, plutôt dans le champs /entries/ de l'entité
/JournalRecord/. Le fait est que dans notre application, nous ne pouvons jamais accéder
à une entrée sans passer d'abord par le jour où cette donnée est stockée[fn:: https://www.mongodb.com/blog/post/building-with-patterns-the-bucket-pattern].

*** Authentifaction et Securité
**** /OAuth2/ simplifié

Dans la mesure où l'application est un /Saas/ et que celle-ci traite des données personnelles, voire des données pouvant
être considéré comme des données de santé, la sécurité des données et de l'application est un point d'une importance primordiale.

L'application utilise un /flow Oauth2/ simplifié[fn:: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/].


**** Vérification et contrôle d'accès


**** Sérialisation/désérialisation des /JWT/ tokens


*** Scanneur de code barre et l'/API/ distante OpenFoodFact

#+CAPTION: Diagramme de séquence de la fonctionnalité de gestion de code barre
[[./img/sequence_scanner.png]]

La gestion de code-barre est régie par plusieurs réglès. Le programme ne va chercher
des élements dans l'/API/ ouverte /OpenFoodFact/ uniquement si aucune nourriture n'est
associée à ce code barre en base de donnée.
L'entité /Food/ contient un champ /barcode/ pour conserver ce code barre.
Le nombre de requètes est donc minimal.

*** Notifications

#+CAPTION: Diagramme de séquence du système de notification
[[./img/sequence_notifications.png]]

Le système de notification utilise le format /FCM/ qui est le format standard de ~Firebase~.
Les messages sont envoyé à l'aide d'un /cron/.
Toutes les heures, une requètes est envoyée à l'application à l'aide d'un compte de service,
un compte en base de donnée, créée pour l'occasion et possédant des droits particuliers.

En fonction de certaines règles métiers, l'utilisateur peut demander à être prévenu
à une certaines fréquence. Si la notification doit être envoyée pendant la requète
courante, alors le /NotificationService/ se connecte à ~Firebase~ (à l'aide de la classe
/FirebaseNotificationClient/), et envoi une requète pour créer un message ~PUSH~.
L'utilisateur reçoit ensuite la notification sur son téléphone ~Android~.

*** /Entries/ génériques

Nous avons vu plus haut qu'un utilisateur pouvait entrer de façon indifférenciée
une prise de nourriture, d'eau ou encore une information de pesée.

Le diagramme suivant montre les différents /design patterns/ mis en oeuvre
pour la réalisation de cette tâche.

#+CAPTION: Diagramme de classes du système d'entrée Générique
[[./img/generic_entries.png]]

A FAIRE

en utilisant le pattern ~Factory~ et le pattern ~Strategy~, nous pouvons donc
créer des Entrées génériques.
Bien que nous ayons vu uniquement la partie création de ces entrées, le même
principe est utiliser dans la création de statistique, avec le même
souci de manipuler ces élements de façon générique.

*** Injection de dépendances

L'injection de dépendance joue un rôle important dans l'architecture du programme.
Elle consiste à faire en sorte que des objets ne soient pas créé directement par
les élements qui en ont besoin, mais à part. Couplé aux interfaces, ce /design pattern/
permet de modifier l'implémentation d'une interface sans modifier le reste du programme.

Concrètement, nous remplaçons ce code:

#+BEGIN_SRC python
def fun():
    dependance : Dependance = Depedance()
#+END_SRC

Par:

#+BEGIN_SRC python
def fun(dependance: Dependance):
    ...
#+END_SRC

Aussi, un système d'injection de dépendance permet d'enregistrer toutes les dépendances dans
des classes de configuration et les utiliser à plusieurs endroit de notre programme.

~FastAPI~ fourni un système d'injection de dépendance via la classe ~Depends()~. Nous utilisons
cette classe pour gérer les dépendances de la couche présentation: en effet, certaines routes
sont dépendantes du système d'authentification ou de permission (il ne sert à rien d'appeler
la logique interne à une route si la dépendance n'existe pas).

Si un utilisateur non autorisé n'est pas habilité à accéder à une route, alors la dépendance
~AuthPassKey~ ne pourra être créée, et par conséquent, l'utilisateur recevra un message d'erreur.
Il en est de même pour le système de contrôle d'accès, via des classes de ~Permission~ et de côntrole
des permissions.

Pour le reste de l'application, nous avons décidé d'utiliser de l'injection manuelle plutôt qu'un container
de dépendance. Nous avons fait cela à cause du nombre limité de dépendances à injecter et par soucis
de créer une couche /Application/ sans dépendance à aucune bibliothèque.

Une classe de configuration existe ainsi par module. Ces classes sont construites de manière à
créer un graphe de dépendance isolé.
Par exemple, la couche métier du module ~notification~ a besoin de 3 élements, 3 dépendances.

1. ~NotificationService~
2. ~NotificationRepository~
3. ~NotificationClient~

Sur ces 3 modules, 2 d'entre eux sont des interfaces dont on peut décider de l'implémentation
dans la classe de configuration. Par exemple, le ~Client~ peut être le client ~Firebase~ ou un client de test.

Dans notre cas, le ~NotificationService~ a besoin des deux autres élements pour être créé (ils sont injectés au
constructeur). Ainsi, la méthode pour accéder à l'instance de ~NotificationRepository~ appelle dans son corps
les méthodes pour créer les ~NotificationRepository~ et ~NotificationClient~:

#+BEGIN_SRC python
class NotificationConfiguration:
    def notification_service(self) -> NotificationService:
        return NotificationService(self.notification_repository(), self.notification_client())
#+END_SRC

La classe de configuration contient uniquement des méthodes qui retournent de nouveaux objets. C'est donc
une classe qui utilise le pattern ~Factory Method~, également, pour éviter de devoir recréer les
objets, la classe utilise le pattern ~Singleton~. Un accès à cette classe donnera toujours la même instance.

La classe est ensuite utilisé dans la couche présentation, qui se contente généralement d'appeler
le /Service/ du module.

*** Tests
- In memory repository (exemple de code)


** Frontend
*** Choix des bibliothèques
**** React
**** Ionic
**** Redux
**** RTK-Query

*** Navigation

** Infrastructure

- Pourquoi docker par exemple
- Pourquoi AWS etc.

* Ergonomie et design

* API

Voici la description de l'/API/, notons que les /endpoints/ de type *POST* retournent l'/UUID/
de la nouvelle ressource dans le /header/ ~HTTP~ ~Location~[fn:: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics#section-9.3.3
"/If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created/"]

** Codes de retour

| Code de retour | Description                                                     |
|----------------+-----------------------------------------------------------------|
|            200 | Retour quand une requètes s'est déroulée comme prévue           |
|----------------+-----------------------------------------------------------------|
|            201 | Retour quand une nouvelle ressource a été créée                 |
|----------------+-----------------------------------------------------------------|
|            204 | Retour quand une ressource a été modifiée                       |
|----------------+-----------------------------------------------------------------|
|            400 | Retour lorsque la requète ~HTTP~ est invalide, comme par exemple|
|                | un mauvais format déclaré (~Content-Type~) ou encore si aucun   |
|                | /payload/ n'a été envoyé à un /endpoint/ qui demande un payload.|
|----------------+-----------------------------------------------------------------|
|            403 | L'utilisateur essaye d'accéder à un /endpoint/ dont il n'a pas  |
|                | la permission. Ou alors, l'utilisateur n'est pas connecté.      |
|----------------+-----------------------------------------------------------------|
|            404 | Retour si la ressource demandée n'existe pas.                   |
|----------------+-----------------------------------------------------------------|
|            409 | Renvoyé lorsqu'on essaye de créer une entitée qui existe        |
|                | déjà. Dans notre application, cette valeur de retour            |
|                | n'est renvoyée uniquement si on essaye de créer un utilisateur  |
|                | avec une adresse email déjà existante.                          |
|----------------+-----------------------------------------------------------------|
|            422 | Erreur de validation, le payload entré n'est pas correct.       |
|                | La description de l'erreur est également renvoyée.              |
|----------------+-----------------------------------------------------------------|
|            500 | Erreur serveur inconnue.                                        |
|----------------+-----------------------------------------------------------------|

** Authentification

| Verbe | URI                 | Description                                                                                              |
|-------+---------------------+----------------------------------------------------------------------------------------------------------|
| POST  | ~/auth/login~       | Permet de se connecter à l'application. Le endpoint utilise la norme                                     |
|       |                     | de flux de mot de passe Oauth2[fn:: https://www.oauth.com/oauth2-servers/access-tokens/password-grant/]. |
|       |                     | Le endpoint retourne un token ~JWT~.                                                                     |
|-------+---------------------+----------------------------------------------------------------------------------------------------------|
| POST  | ~/auth/register~    | Ce /endpoint/ permet de créer un nouvel utilisateur.                                                     |
|       |                     | Retourne également un ~JWT~ valide.                                                                      |
|-------+---------------------+----------------------------------------------------------------------------------------------------------|
| GET   | ~/auth/verify~      | Ce /endpoint/ permet de vérifier la validité d'un token. Il ne fait que retourner                        |
|       |                     | 200 si le token est valide et 403 is il est invalide.                                                    |
|-------+---------------------+----------------------------------------------------------------------------------------------------------|
| POST  | ~/auth/permissions~ | Permet de modifier les permissions d'un utilisateur. Seuls les utilisateurs                              |
|       |                     | ayant la permission "~change_permission~" peuvent modifier celles-ci.                                    |
|-------+---------------------+----------------------------------------------------------------------------------------------------------|

** Food

| Verbe  | URI                 | Description                                                            |
|--------+---------------------+------------------------------------------------------------------------|
| GET    | ~/food/~            | Liste les entités /Food/ disponibles. Un argument optionel permet de   |
|        |                     | chercher les entitées par leur nom.                                    |
|        |                     | Les entitées ainsi retournées sont une version tronquée de l'entitée   |
|        |                     | /Food/ par soucis de performance.                                      |
|--------+---------------------+------------------------------------------------------------------------|
| GET    | ~/food/{food_uuid}~ | Permet d'obtenir une entitée /Food/ par sont ~UUID~.                   |
|--------+---------------------+------------------------------------------------------------------------|
| POST   | ~/food/~            | /Endpoint/ pour créer une nouvelle entitée de type /Food/.             |
|--------+---------------------+------------------------------------------------------------------------|
| DELETE | ~/food/{food_uuid}~ | Permet de supprimer une entitée /Food/, les utilisateurs ne peuvent    |
|        |                     | supprimer uniquement les entitées qu'ils ont créés.                    |
|--------+---------------------+------------------------------------------------------------------------|
| POST   | ~/food/barcode~     | Permet de créer une nourriture à partir d'un code barre.               |
|        |                     | Nous avons vu le fonctionnement particulier de ce /endpoint/ plus haut |
|        |                     | dans ce document.                                                      |
|--------+---------------------+------------------------------------------------------------------------|


** Entry

| Verbe  | URI                          | Description                                            |
|--------+------------------------------+--------------------------------------------------------|
| GET    | ~/entry/{date}/{entry_uuid}~ | Permet de récupérer une entrée de journal en utilisant |
|        |                              | son ~UUID~ et une date.                                |
|--------+------------------------------+--------------------------------------------------------|
| GET    | ~/entry/{date}~              | List les entrées de journal pour une date donnée.      |
|--------+------------------------------+--------------------------------------------------------|
| POST   | ~/entry~                     | Permet de créer une entrée de journal. L'entrée peut   |
|        |                              | être de plusieurs type, comme nous l'avons vu plus     |
|        |                              | haut dans le document.                                 |
|--------+------------------------------+--------------------------------------------------------|
| DELETE | ~/entry/{date}/{entry_uuid}~ | Permet de supprimer une entrée de journal.             |
|--------+------------------------------+--------------------------------------------------------|

** User

| Verbe | URI                        | Description                                               |
|-------+----------------------------+-----------------------------------------------------------|
| GET   | ~/user/~                   | Permet de récupérer les informations de l'utilisateur     |
|       |                            | connecté.                                                 |
|-------+----------------------------+-----------------------------------------------------------|
| PUT   | ~/user/~                   | Permet de modifier les informations de l'utilisateur      |
|       |                            | connecté.                                                 |
|-------+----------------------------+-----------------------------------------------------------|
| PUT   | ~/user/goals~              | Permet de modifier les informations de l'entité /Goal/    |
|       |                            | associé à l'utilisateur.                                  |
|-------+----------------------------+-----------------------------------------------------------|
| PUT   | ~/user/water-notification~ | Permet de modifier les caractéristiques des notifications |
|       |                            | de l'utilisateur.                                         |
|-------+----------------------------+-----------------------------------------------------------|

** Notifications

| Verbe | URI                       | Description                                                |
|-------+---------------------------+------------------------------------------------------------|
| put   | ~/notification/token~     | Permet de modifier le token d'authentification pour        |
|       |                           | l'utilisateur connecté. Cet /endpoint/ est appelé          |
|       |                           | automatiquement par le /frontend/ si la connection         |
|       |                           | avec ~Firebase~ a réussi et que l'utilisateur              |
|       |                           | est sur Android. Le ~token~ est enfait un identifiant      |
|       |                           | unique donné par ~Firebase~. Nous avons vu plus haut       |
|       |                           | ce fonctionnement.                                         |
|-------+---------------------------+------------------------------------------------------------|
| post  | ~/notification/send-test~ | Permet d'envoyer une notification de test. Ne fonctionne   |
|       |                           | qu'à la condition qu'un ~token~ existe pour l'utilisateur  |
|       |                           | courant.                                                   |
|-------+---------------------------+------------------------------------------------------------|
| post  | ~/notification/schedule~  | /Endpoint/ de Service, est utilisé par le /backend/ pour   |
|       |                           | envoyer les notifications à tous les utilisateurs.         |
|       |                           | Nous avons également vu ce fonctionnement plus haut.       |
|       |                           | L'utilisateur doit posséder la permission                  |
|       |                           | "~schedule_notifications~"                                 |
|-------+---------------------------+------------------------------------------------------------|
| post  | ~/notification/send~      | /Endpoint/ de service, permet d'envoyer une notification à |
|       |                           | un utilisateur. surtout utile pour des tests.              |
|       |                           | L'utilisateur doit posséder la permission                  |
|       |                           | "~send_notification_to_any_user~".                         |
|-------+---------------------------+------------------------------------------------------------|

** Report

| Verbe | URI        | Description                                         |
|-------+------------+-----------------------------------------------------|
| GET   | ~/report/~ | /Enpoint/ pour récupérer des statistiques. La route |
|       |            | prend plusieurs paramètres optionnels pour décider  |
|       |            | quelle statistiques doivent être accédées.          |
|-------+------------+-----------------------------------------------------|

** Debug

| Verbe | URI       | Description                                                             |
|-------+-----------+-------------------------------------------------------------------------|
| POST  | ~/debug/~ | Un /endpoint/ qui est utilisé par l'application /frontend/ pour envoyer |
|       |           | certains messages au /backend/ ces messages sont visibles dans les logs |
|       |           | du serveur. L'intéret est de pouvoir obtenir des informations de        |
|       |           | debuggage lorsque certaines conditions ne permettent pas facilement d'y |
|       |           | accéder.                                                                |
|-------+-----------+-------------------------------------------------------------------------|

* Lexique

| Terme           | Définition                                                                      |
|-----------------+---------------------------------------------------------------------------------|
| API             | Signifie /Application Programming Interface/                                    |
|                 | il s'agit d'une interface qui permet de faire                                   |
|                 | communiquer plusieurs programmes entre eux. Les programmes                      |
|                 | peuvent être rapproché ou distants.                                             |
|-----------------+---------------------------------------------------------------------------------|
| Multi-platforme | Un logiciel est dis multi-platforme si il peux fonctionner                      |
|                 | sur plusieurs plateforme, machines ou systèmes d'exploitations                  |
|                 | différents.                                                                     |
|-----------------+---------------------------------------------------------------------------------|
| IHM             | Interface homme machine, décrit les interfaces permettants à                    |
|                 | un utilisateur d'intéragir avec l'application.                                  |
|-----------------+---------------------------------------------------------------------------------|
| Frontend        | La partie de l'application visible par l'utilisateur.                           |
|                 | Elle comprends à la fois l'IHM et le système permettant à                       |
|                 | cette partie de se connecter aux autres parties de                              |
|                 | l'application.                                                                  |
|-----------------+---------------------------------------------------------------------------------|
| Backend         | Partie de l'application qui n'est pas visible à l'utilisateur.                  |
|                 | Elle comprends notamment le traitement et stockages des données et              |
|                 | l'execution de la logique métier.                                               |
|-----------------+---------------------------------------------------------------------------------|
| Framework       | Un /framework/ ou canevas en anglais est un ensemble de                         |
|                 | bibliothèques logicielles permettant de faciliter la                            |
|                 | programmation de certaines tâches. Souvent les /frameworks/                     |
|                 | induisent une façon particulière de programmer                                  |
|-----------------+---------------------------------------------------------------------------------|
| Bibliothèque    | Code pré-exisant permettant de régler un problème, ou                           |
|                 | permettant d'implémenter certaines fonctionnalités. Ce code                     |
|                 | est conçu pour être réutilisable entre plusieurs applications                   |
|-----------------+---------------------------------------------------------------------------------|
| Environnement   | Un environnement d'execution ou /runtime/ en anglais est un                     |
| d'execution     | programme qui fournit certaines fonctionnalités à un autre                      |
|                 | programme pour être éxecuté. Dans le cas qui nous interesse                     |
|                 | pendant ce document, l'environnement d'execution permet                         |
|                 | spécifiquement de faire fonctionner du code asynchrone                          |
|                 | en ~Python~.                                                                    |
|-----------------+---------------------------------------------------------------------------------|
| Plugin          | Un plugin est un partie optionnelle d'un programme                              |
|                 | qui peut-être branché à un programme principale pour ajouter                    |
|                 | des fonctionnalités. On parle également d'"architecture plugins"                |
|                 | pour parler des architectures logicielles qui simplifie la                      |
|                 | création de nouvelles fonctionnalités interchangeables dans.                    |
|                 | un programme                                                                    |
|-----------------+---------------------------------------------------------------------------------|
| Emulateur       | Un émulateur est un programme qui se comporte comme une machine                 |
|                 | particulière. Nous utiliserons notamment un émulateur                           |
|                 | Android pour faire fonctionner notre programme comme si                         |
|                 | il fonctionnait sur Android                                                     |
|-----------------+---------------------------------------------------------------------------------|
| Saas            | Sigle anglais signifiant /Software as a Service/ c'est un type                  |
|                 | de programme qui n'est pas installé sur la machine d'un                         |
|                 | utilisateur mais qui fonctionne de façon distante.                              |
|-----------------+---------------------------------------------------------------------------------|
| Serveur virtuel | Un serveur virtuel est une instance de serveur qui fonctionne sur un système    |
|                 | d'exploitation hôte en partageant ses ressources matérielles.                   |
|                 | Des logiciels appelés /hyperviseurs/ permettent de faire fonctionner            |
|                 | plusieurs serveurs virtuels sur la même machine physique.                       |
|-----------------+---------------------------------------------------------------------------------|
| Container       | Un container est un environnement isolé du reste du système                     |
|                 | d'exploitation. Un container permet de garantir qu'un                           |
|                 | programme fonctionnera de la même façon quelque soit le système                 |
|                 | d'exploitation qui fait fonctionner le container.                               |
|                 | Un container /Docker/ est quant a lui un type spéciale de                       |
|                 | container qui utilise le programme /Docker/ pour rendre                         |
|                 | ce container réutilisable entre plusieurs installations                         |
|                 | à l'aide d'un fichier de configuration appelé /Dockerfile/                      |
|-----------------+---------------------------------------------------------------------------------|
| Cache           | Le cache est une mémoire tampon qui est utilisée en informatique pour           |
|                 | éviter de refaire un calcul ou de récupérer des données identiques plusieurs    |
|                 | fois.                                                                           |
|-----------------+---------------------------------------------------------------------------------|
| Interface       | Dans le contexte de la programmation orientée objet, une interface est un       |
|                 | élement d'architecture qui permet de définir les contrats que doit              |
|                 | suivre un classe pour pouvoir implémenter l'interface.                          |
|                 | Le but est généralement de créer des programmes modulaires dans lesquels        |
|                 | plusieurs implémentation d'une interface existent. Par exemple, on peut définir |
|                 | une interface "Séquence" qui comprends les méthodes "longueur" et "estVide".    |
|                 | Les implémentations de cette interface devront toutes implémenter ces deux      |
|                 | méthodes.                                                                       |
|-----------------+---------------------------------------------------------------------------------|
| Type            | Un type défini des caractéristiques inhérentes à certains élements dans un      |
|                 | programme. La notion de type peut être considéré comme une généralisation       |
|                 | de la notion d'interface aux interfaces elles mêmes et aux types                |
|                 | primitifs d'un langage.                                                         |
|-----------------+---------------------------------------------------------------------------------|
| Implémentation  | Dans un contexte orienté objet, on parle de l'implémentation d'une interface.   |
|                 | Une implémentation est une classe qui implémente les méthodes d'une interface   |
|                 | donnée.                                                                         |
|-----------------+---------------------------------------------------------------------------------|
| Design pattern  | Un /design pattern/ est une collection de classes agencée de façon précises     |
|                 | entre elles dans le but de répondre à un problème connu et documenté.           |
|                 | On dit que les design patterns ne sont pas inventé mais découverts.             |
|-----------------+---------------------------------------------------------------------------------|

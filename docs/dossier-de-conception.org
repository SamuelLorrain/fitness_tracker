#+begin_export latex
\renewcommand{\contentsname}{Table des matières}
\clearpage \tableofcontents \clearpage
#+end_export

* Introduction

** Objectif du document

   L'objectif du document est de présenter les choix et la conception détaillée de l'application *Fitness Tracker*
   en réponse au cahier des charges précédemment établi. Ainsi que présenter certaines solutions
   techniques aux problèmes rencontrés pendant le développement.

** Rappel du projet

   Le projet vise à développer une application de suivi de bien-être
   et sportif. Les principales fonctionnalités consistent à rentrer des
   données de nutrition, ou d'autres données relatives aux sport
   et de suivre l'évolution de certaines tendances dans le temps.

   L'application doit être multi-platforme. Elle est composée à
   la fois d'un /frontend/, application web hybride et un /backend/,
   Une /API/ est chargée de faire la communication entre les deux éléments.

** Environnement de développement

   | Réalisation               | Outils                                                             |
   |---------------------------+--------------------------------------------------------------------|
   | Application serveur       | ~Python 3.11~;                                                     |
   |                           | ~FastAPI 0.110~, un /framework/ web specialisé dans la création d'/API/; |
   |                           | ~mypy 1.9~, un outil de typage statique pour Python;               |
   |---------------------------+--------------------------------------------------------------------|
   | Application mobile et web | ~Ionic/React~, un /framework/ de création d'interface mobile utilisant |
   |                           | la bibliothèque ~React~ comme moteur d'interface graphique;        |
   |                           | ~Capacitor~, un environnement d'exécution permettant d'utiliser    |
   |                           | les applications web comme des applications mobiles natives,       |
   |                           | ~Capacitor~ est un successeur de ~Cordova~ et ~PhoneGap~.;         |
   |                           | Et inclut des plugins pour des applications natives comme          |
   |                           | la lecture de code bar.                                            |
   |                           | ~Redux~, ~Redux-Toolkit~ et ~RTK-Query~, des outils de             |
   |                           | gestion d'état global de l'application.                            |
   |---------------------------+--------------------------------------------------------------------|
   | Applications natives      | ~Android Studio~ pour la partie ~Android~;                         |
   |                           | De véritables smartphones android vont être utilisés               |
   |                           | durant le développement. Egalement, utilisation des émulateurs     |
   |                           | présents dans les environnements de développements natifs.         |
   |---------------------------+--------------------------------------------------------------------|
   | Gestion de développement  | ~Git~ pour le developpement et ~Github~ pour l'hébergement du      |
   |                           | code, ainsi que les pipelines de vérification.                     |
   |---------------------------+--------------------------------------------------------------------|
   | Gestion de projet         | ~Trello~ un outil de gestion de projet de type "board kanban"      |
   |---------------------------+--------------------------------------------------------------------|
   | Redaction de documents    | ~Latex~ et ~vim~, en utilisant un plugin ~Orgmode~ et ~pandoc~     |
   |                           | pour la réalisation du document final (pdf)                        |
   |---------------------------+--------------------------------------------------------------------|
   | Redaction de diagrammes   | ~diagrams.net~ un outil en ligne de réalisation de        |
   | UML                       | diagrammes                                                         |
   |---------------------------+--------------------------------------------------------------------|

* Vue d'ensemble de l'architecture

L'application est séparée en 3 parties distinctes. L'/architecture système/ concerne
les logiciels et matériels (ou matériels virtuels) nécessaires à l'hébergement et
à la mise en production de l'application.
Le /backend/ constitue la partie logique de l'application ainsi que la persistence des
données utilisateur. Le /frontend/ est quant à lui responsable de l'interface homme machine
permettant la réalisation des différentes taches de l'application.

Une telle architecture peut être considérée comme un /Saas/, car l'application n'a pas
besoin d'être installée pour que l'utilisateur ait la capacité de l'utiliser (dans sa version webapp),
la version mobile du frontend ne servant qu'a accéder à certaines fonctionnalités non essentielles au
fonctionnement et à améliorer les peformances[fn:: il n'y a pas besoin de télécharger le fichier js à chaque fois
que l'on accède à l'application mobile].
Comme la persistence des données est au niveau du /backend/, non accessible à l'utilisateur,
le développeur est responsable de la maintenance et de l'exploitation des données sur l'application.

** Architecture système et déploiement

   L'application est aujourd'hui déployée dans sa majorité sur un serveur virtuel ~AWS EC2~.
   Les composants de l'architecture système sont les suivant:

#+CAPTION: Architecture système
#+ATTR_HTML: :width 300px
   [[./img/architecture_systeme.png]]

   1. ~Mongo DB~ : Une base de donnée /NoSQL/ orientée document. Toutes les donneés de l'application y sont stockées;
   2. ~Firebase~ : Un service utilisé pour les notifications push, utilise le ~Firebase Cloud Messaging~ (~FCM~);
   3. ~Amazon EC2~ : Un service de serveur virtuel fonctionnant sur la distribution Linux ~Amazon Linux 2~.
      Est utilisé pour lancer des /containers/ ~Docker~;
   4. ~Amazon S3~ : Un service de stockage de fichier statique et d'hébergement de ces fichiers. Héberge l'application
      web (un fichier ~index.html~ et un fichier ~index.js~)
   5. ~Docker~ : Logiciel de /containerisation/ de l'application, est utilisé pour configurer et stocker les environnements
      nécessaires à l'installation de l'application /backend/.
   6. ~Docker compose~ : Décrit les interactions entre les différents /containers/ ainsi que les interactions avec
      l'exterieur des /containers/, comme le stockage ou les ports réseaux.

** Backend

   L'application ~backend~ est constituée de plusieurs éléments. Outre ceux déjà présentés,
   celle-ci comprends:

#+CAPTION: Architecture backend
#+ATTR_HTML: :width 300px
   [[./img/architecture_backend.png]]

   1. ~FastAPI~: un framework web ~Python~, centré sur des fonctionnalités de validation d'entrée typées et
      de sérialisation/désérialisation.
   2. ~Uvicorn~ : Un serveur ASGI (~Asynchronus Server Gateway interface~) qui agit comme un environnement
      d'execution asynchrone et web pour ~Python~. Ce serveur permet donc de faire fonctionner l'application ~Python~
      en mode asynchrone.
   3. Une architecture en couche, inspirée par ~Clean Architecture~:
      Il y a une couche ~Domaine~, qui décrit les ~Entitées~ et ~Aggregats~ du systême, une couche ~Infrastrucutre~,
      utilisée pour les implémentations comme le stockage du reste de l'application.
      Une couche de ~Presentation~ qui permet de communiquer avec l'extérieur, ainsi qu'une couche ~Application~ (ou Service)
      qui s'occupe de l'orchestration entre les autres élements de l'application. Nous détaillons cette architecture
      dans la suite du document.


** Frontend (application hybride)

   L'application ~frontend~ comprends quant à elle ces éléments:

#+CAPTION: Architecture frontend
#+ATTR_HTML: :height 300px
   [[./img/architecture_frontend.png]]

   1. ~React~: Une bibliothèque de rendu "réactive". Permet de créer des interfaces graphiques complexes en ~HTMl~ et ~typescript~.
      Est également utilisée comme une couche d'abstraction au dessus d'~HTML~, grace au ~JSX~.
      Est aussi à la base d'un écosystèmes de bibliothèques.
   2. ~Redux~: Une bibliothèque qui permet d'utiliser le pattern ~Flux~ (une variation du pattern MVC[fn:: https://facebookarchive.github.io/flux/docs/in-depth-overview/]) pour gèrer l'état de l'application.
      L'état ainsi stocké dans ~Redux~ permet de rendre l'application plus prédictible car celui-ci est centralisé mis à jour et utilisé
      par un flux unidirectionnel. Nous détaillons ce point dans la suite du document.
   4. ~RTK-Query~: Un moteur de requète ~AJAX~ compatible avec ~Redux~. Gère le cache et l'invalidation de cache, ainsi que les états
      des requètes ("pending", "error" ,"loading" etc.)
   4. ~Ionic~: A la fois une bibliothèque graphique de composants ~React~ répliquant le visuel des composants natif ~Android~ et ~Ios~ et
      une abstraction pour effectuer certaines tâches liées à ~Capacitor~ (~inoic cli~)
   5. ~Capacitor~: Fournit une abstraction entre les composants ~Ionic~ et les applications natives ~Ios~ et ~Android~. Permet également
      d'utiliser des fonctionnalités natives des téléphones normalement inaccessibles à une application web. Certains plugins permettent
      notamment d'utiliser le /GPS/ du téléphone, ou encore les fonctionnalités de stockage.

* Conception
** Concepts généraux

*** SOLID

Les principes /SOLID/ contribuent de manière significative à l’élaboration
de logiciels modulaires, évolutifs et maintenables.

Dans le cadre de notre programme, l'application de ces principes
nous a aidé à la mise en place de test unitaire grâce à *D*, l'injection de dépendance,
qui permet de modifier une base de donnée en une version /in memory/
permettant des tests rapides. Ou encore de tester en isolation les
services et le domaine.

De la même façon le *S*, principe de responsabilité unique (/Separation of concern/), nous donne
une ligne directrice dans l'élaboration des différentes classes utilisées
dans notre programme. En effet, l'application de ce principe permet
une architecture plus modulaire, car la responsabilité unique implique
qu'une classe "n'ait qu'une seule raison de changer"[fn:: Martin, Robert C. (2003). Agile Software Development, Principles, Patterns, and Practices. . p. 95].
Cela permet de garantir la réutilisation et la modularité du code
en diminuant l'interdépendance entre les classes:
si une classe n'a qu'une raison de changer, alors, modifier une classe
revient à modifier une fonctionnalité. Chaque classe ayant un rôle
précis dans l'application.

Les 3 autres principes ont été moins utilisés durant l'élaboration
du programme.

Tout d'abord, *L*, le principe de substitution de Liskov est garanti
par le caractère dynamique des classes. ~Mypy~, le logiciel de vérification
de type statique de ~Python~ ne permet pas de créer des classes qui transgresserait
ce principe[fn:: https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides].
Nous pouvons cependant noter que celui-ci apparait uniquement dans le cadre
de l'héritage, et qu'il n'y en a pas dans notre programme.

Les principes *O* Ouvert/fermé et *I*, Ségragation des interfaces, ne
sont que peu utilisés. Ces principes s'imposent
lorsque la base de code devient plus importante, en effet il n'y a que
peu d'interfaces, et l'unique utilisation du principe *O* est dans
l'élaboration des /Entries/ génériques. Nous en parlerons plus loin.

*** Inspiration REST

/REST/ (/REpresentational State Transfer/) est un style d'architecture visant
à simplifier la communication client serveur en assignant une /URI/ (/Unique Ressource Identifier/)
à chaque ressource, et à utiliser les verbes ~HTTP~ pour signifier l'intention
du client par rapport à ces ressources. Le serveur doit quant à lui utiliser les codes
de retour ~HTTP~ pour signifier l'état du traitement de la demande du client.
Aussi une architecture /REST/ doit être "découvrable" (/discoverable/).
C'est à dire qu'un client doit avoir connaissance facilement du reste de l'application
à partir d'une première requète. Grâce à l'utilisation d'hyperliens par exemple.
Dans notre cas, le /backend/ agit comme le serveur et le /frontend/ comme le client.

Notons que /REST/ n'est pas une norme, mais plutôt une série de principes.

Le but de ce style d'architecture est de garantir une commmunication /stateless/, "sans état", entre
le client et le serveur. C'est à dire que ni le client, ni le serveur n'ont besoin de conserver
un état sur l'un ou l'autre pour communiquer. Il y a notamment la garantie que le client
accèdera toujours à la même ressource via la même /URI/.

Nous n'allons pas utiliser totalement le style d'architecture /REST/, mais se concentrer
seulement sur les /URI/ et les verbes et code de retour ~HTTP~, car, dans le cadre d'une /API/ les autres notions
sont peut généralement peu utile et en pratique peut utilisées, au grand désarroi de l'auteur[fn:: https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven].

Pour garantir ces principes, nous avons besoin de plusieurs choses:

1. Des identifiants uniques par ressource (/URI/). Nous utiliserons les /UUID4/, qui est un format d'identifiant unique généré aléatoirement.
   La version 4 est privilégiée car elle utilise un générateur de nombre aléatoire plutôt que des caractéristiques du serveur
   (comme son adresse MAC[fn:: https://datatracker.ietf.org/doc/html/rfc4122, voir la section "Identifier uniqueness considerations"])
2. Les verbes ~HTTP~ doivent correspondre à des actions précises:

   - *GET* permet de lister ou obtenir une ou des ressources
   - *POST* permet de créer une ressource
   - *PUT* permet de modifier une ressource
   - *DELETE* permet de supprimer une ressource

   Nous avons décidé de ne pas utiliser *PATCH*, car, bien qu'il soit défini comme un moyen de modifier une partie d'une ressource,
   il implique également que le client ait connaissance de la manière dont sont considérées les parties non transmises dans la requête *PATCH*. Cela peut porter
   à confusion, notamment quand certains champs de la ressource sont optionnels.

3. Les actions doivent donner lieu à des opérations et des retours serveurs non-ambigus.
   Par exemple, la création d'une ressource ne doit pas retourner directement le contenu de la ressource créée mais
   uniquement l'/URI/ de la nouvelle donnée créée. A la fois pour des raisons de performance, et de séparation
   de responsabilité: un *POST* ne doit pas retourner les données à la manière d'un *GET*.

Nous verrons le détail les différents /endpoints/ de l'/API/ dans la suite du document.

** Backend
*** Choix des bibliothèques
**** Python
Le choix de ~Python~ comme language de programmation a été motivé par plusieurs points.
La première idée était d'utiliser des bibliothèques de /machine learning/ et /data science/
comme ~Panda~ et ~Scikit-learn~ pour créer une fonctionnalité de mesure automatique de calories
à partir de photographies. ces bibliothèques sont disponible en ~Python~, et les documentations
en ligne sur ce genre de sujet utilisent surtout ce langage. ~Python~ étant un des langages les plus utilisés en /data science/[fn:: https://www.dasca.org/world-of-data-science/article/which-programming-language-is-ideal-for-data-science-python-or-r ]
Cependant il s'est trouvé que la quantité et la qualité des
données requises pour une telle tâche n'a pas permit d'aboutir à un résultat pour le moment.

~Python~ offre cependant certains avantages par rapport à d'autres languages.
Comme c'est un langage interprété, le déploiement ne demande pas de phase de compilation.

Un certain nombre de fonctionalitéds du langage simplifient aussi le développement
comme par exemple les décorateurs[fn:: une version "statique" du pattern décorateur, que l'on
peut implémenter à l'aide des annotations en ~Java~ par exemple.] ou
son caractère multi-paradigme : à la fois orienté objet[fn:: avec des classes "simples" ou des "dataclasses",
qui ont sont l'équivalent ~Python~ des ~records~ en ~Java~ ou ~C#~.],
fonctionnel[fn:: en ~Python~, les fonctions sont considérés comme des "citoyens de premiere classe", on peut
donc les utiliser comme des valeurs, et les passer en paramètre. De plus, la bibliothèque standard propose
des fonctionalités typique d'un language fonctionnel comme des fonctions ~map~, ~filter~, ~reduce~, ~zip~, ~takewhile~...
On peut également créer des listes en intention à la manière d'~Haskell~, ou encore faire de l'/itération paresseuse/ grâce aux ~generateurs~ ]
et impératif.
Les bibliothèques utilisés dans le projets fonctionnent constamment à travers cette approche multi-paradigme.

La notion de typage optionel et incremental[fn:: https://peps.python.org/pep-0484/] permet de faciliter
le développement tout en garantissant un sécurité des types (à l'inverse des langages dynamiques classiques).
Le /Structural duck typing/, notion propre à ~Python~, remplace la notion d'interface dans un contexte de typage dynamique[fn:: https://peps.python.org/pep-0544/]

Enfin, l'écosystème est adapté au developpement web incremental et rapide. De nombreuses bibliothèques et /frameworks/ existent
pour nous aider à développer une /API/. Et il nous a semblé que ~Python~ privilégiait une approche "bibliothèque" plutôt qu'une
approche "/framework/", ce qui permet de tester et éprouver des /design patterns/ qui n'auraient pas été prévu
par tel ou tel /framework/.


**** FastAPI
Nous avons choisi ~FastAPI~ comme /framework/ web principal.
Il est léger et spécialisé : il été conçu uniquement pour
la création d'/API/, à l'inverse de la plupart des autres /frameworks/
web qui proposent des écosystèmes logiciels complets (allant parfois
du déploiement jusqu'au style de page[fn:: Par exemple ASP.NET]).

~FastAPI~ inclu une validation des données et une serialisation/désérialisation par typage fort
en utilisant la librairie ~Pydantic~. Ainsi, nous pouvons garantir que les entrées et sorties
de l'application sont typés, évitant ainsi une classe entière d'erreurs.
Nous avons aussi utilisé le système d'injection de dépendance intégré, les middleware,
ainsi que les abstractions au dessus de systèmes d'authentification comme ~OAuth2~.
Enfin, ~FastAPI~ génère automatiquement une documentation ~OpenAPI~, ce qui faisait
parti de nos exigences fonctionnelles.

**** Mypy

~Mypy~ est un système de vérification statique de typage en ~Python~.
Il permet de s'assurer de la cohérence des types de l'application sans la lancer.
Par exemple, ~Mypy~ peut déterminer si une fonction qui retourne un ~int~, retourne, en
effet un ~int~. ~Mypy~ fonctionne de concert avec ~FastAPI~ et ~Pydantic~.

**** Autre bibliothèques

Nous utilisons d'autres dépendances dans le projets:

- ~requests~, un client ~HTTP~ pour permettre au serveur d'effectuer des requètes
- ~py-jwt~, une bibliothèque d'encodage et décodage des tokens ~JWT~ (a voir dans la suite du document)
- ~pymongo~, un driver ~MongoDB~ pour ~Python~, qui permet de connecter la base de donnée à l'application
- ~isort~ et ~black~, des outils pour formatter le code de façon standard[fn:: https://peps.python.org/pep-0008/]
- ~pytest~ et ~coverage~, des bibliothèques de test unitaire et de controle de couverture de tests.
- d'autres bibliothèques auxilliaires pour quelques fonctionnalités optionnelles de ~Pydantic~ et l'accès à ~Firebase~.

*** Clean Architecture

Le /backend/ été conçu en suivant les principes de la /Clean Architecure/. C'est
une des différentes façons d'implémenter /SOLID/ dans un context d'application utilisateur (par opposition à une bibliothèque).
Le principe est de séparer l'application en plusieurs couches distinctes et indépendantes, et de ne permettre qu'un petit ensemble de
communication entre ces couches. Cette structure permet d'isoler la logique métier des interfaces utilisateurs et des infrastructures.

Concrètement, /Clean Architecture/ défini 4 couches: /Domaine/, /Présentation/, /Application/, /Infrastructure/, ayant
chacune un rôle distinct.

- La couche /Domaine/ contient les /Entitées/ et /Aggregats/, soit, les objets domaine de l'application. Dans notre cas,
  un /User/ ou encore une nourriture (/Food/) est une /Entitité/.
  Ce sont des classes "simples", sans référence à la base de donnée où à quelconque technologie ou entrée/sortie particulière.

- La couche /Présentation/ est dédiée à l'interface entre l'application et l'extérieur. Il s'agit dans notre cas de
  la partie de l'application qui s'occupe des /Contrats/ des requètes et réponses ~HTTP~ (leur format) ainsi que les
  règles de validation associées. C'est la seule couche de l'application qui fait directement référence à ~FastAPI~.

- La couche /Application/ ou /Service/ a pour fonction de décrire des opérations concrètes sur les /Entitées/, et de
  faire le lien entre plusieurs couches. Par exemple, c'est cette couche qui détermine si telle action doit utiliser
  telle méthode d'un /Repository/.
  Pour garantir une approche /SOLID/, elle ne fait pas directement référence aux implémentations, mais uniquement aux
  interfaces qui sont implémentées dans la couche /Infrastructures/.
  Les interfaces sont d'ailleurs déclarées dans la couche application.

- La couche /Infrastructure/ contient les implémentations des interfaces. Les autres couches ne font jamais de référence
  directes à cette couche. C'est un système de configuration (liée à de l'injection de dépendance) qui s'occupe
  de dispatcher la bonne implémentation pour le cas d'utilisation ou l'environnement voulu.
  Dans notre cas, la couche infrastructure implémente principalement les /Repositories/ ainsi que les méthodes d'authentification:
  La classe qui s'occupe de sérializer et désérializer les ~JWT~ en class d'authentification /AuthPassKey/, est une implémentation
  concrète de la classe /AuthFormatter/ (/JWTAuthFormatter/).

- Des classes de /Configuration/ sont également utilisées pour créer de l'injection de dépendances (soit, définir quelle implémentation
  doit implémenter telle interface dans tel contexte). D'ailleurs, la configuration n'a pas besoin de déterminer
  statiquement quelle implémentation doit être utilisé dans tel cas, mais peut utiliser une /Factory/ pour déterminer dynamiquement
  quelle classe doit être utilisée dans un cas d'utilisation précis (voir le /design pattern/ /Strategy/)

  MONTRER UN EXEMPLE DE MODULE DE L'APPLICATION À L'AIDE D'UN DIAGRAMME UML
  ==> a la fois un diagramme UML et un diagramme de séquence

*** Domaine
Voici une vue d'ensemble des entitées et aggrégats de l'application:

#+CAPTION: Entitées et aggregats
[[./img/domaine.png]]

ATTENTION JE CROIS QU'IL FAUT MODIFIER LE SCHEMA POUR SEPARER LES COMPOSITIONS ET AGGREGATIONS
OK BON C'EST SURTOUT ILLISIBLE, ON VA FAIRE PLUSIEURS PARTIES:

1. Nutrition

2. User

3. Entries

Comme nous pouvons le voir, la majorité des classes sont liés entre elles par
de la composition ou de l'aggregation.
Aussi, les différents types d'entrées sont des implémentations différents
de l'interface /Entry/, ce qui permet d'en rajouter à la volée dans l'application.
Et ainsi rendre celle-ci facilement extensible.
Le domaine étant "plat", sans notion d'héritage la modularité est conservée au maximum.

*** Infrastructure
- Différence entre le mapping et
*** Presentation
**** Authentifaction et Securité
***** OAuth2
***** Connection et enregistrement
***** Permissions
***** Vérification et contrôle d'accès

*** Tests

*** Diagramme de séquence

OU EST CE QU'ON DÉCRIT LES PATTERNS UTILISÉS ? JE PENSE DANS LES SECTIONS

** Frontend
*** Choix des bibliothèques
**** React
**** Ionic
**** Redux
**** RTK-Query

*** Navigation

** Infrastructure
- Pourquoi docker par exemple
- Pourquoi AWS etc.

** Securité

Dans la mesure où l'application est un /Saas/ et que celle-ci traite des données personnelles, voire des données pouvant
être considéré comme des données de santé, la sécurité des données et de l'application est un point d'une importance primordiale.

Bien que nous puissons adopter plusieurs point de vue concernant la sécurité, nous privilégierons une approche pratique. Pour
cela, nous allons nous concentrer sur le /TOP 10 OWASP/[fn:: https://owasp.org/www-project-top-ten/] considéré comme un
standard de l'industrie[fn:: comme par exemple par le /MITRE/, https://cwe.mitre.org/data/definitions/1344.html], et allons voir comment
nous mitigons ces points dans l'application.

(Parle de tous le reste du chapitre, mais en se concentrant sur la sécurité)

* Ergonomie et design

* API

** Food
*** create food
*** list food
*** get food
*** delete food
*** process food barcode

** Entry
*** create entry
*** list entry
*** get entry
*** delete entry

** User
*** get current user infos
*** set current user goals
*** set current user basic infos
*** set current user water notification

** Notifications
*** set notification token
*** send test notification
*** schedule notifications
*** send notification to user

** Report
*** get stats

** Debug
*** post debug entry

* Lexique

| Terme           | Définition                                                                      |
|-----------------+---------------------------------------------------------------------------------|
| API             | Signifie /Application Programming Interface/                                    |
|                 | il s'agit d'une interface qui permet de faire                                   |
|                 | communiquer plusieurs programmes entre eux. Les programmes                      |
|                 | peuvent être rapproché ou distants.                                             |
|-----------------+---------------------------------------------------------------------------------|
| multi-platforme | Un logiciel est dis multi-platforme si il peux fonctionner                      |
|                 | sur plusieurs plateforme, machines ou systèmes d'exploitations                  |
|                 | différents.                                                                     |
|-----------------+---------------------------------------------------------------------------------|
| IHM             | Interface homme machine, décrit les interfaces permettants à                    |
|                 | un utilisateur d'intéragir avec l'application.                                  |
|-----------------+---------------------------------------------------------------------------------|
| frontend        | La partie de l'application visible par l'utilisateur.                           |
|                 | Elle comprends à la fois l'IHM et le système permettant à                       |
|                 | cette partie de se connecter aux autres parties de                              |
|                 | l'application.                                                                  |
|-----------------+---------------------------------------------------------------------------------|
| backend         |                                                                                 |
|-----------------+---------------------------------------------------------------------------------|
| framework       | Un /framework/ ou canevas en anglais est un ensemble de                         |
|                 | bibliothèques logicielles permettant de faciliter la                            |
|                 | programmation de certaines tâches. Souvent les /frameworks/                     |
|                 | induisent une façon particulière de programmer                                  |
|-----------------+---------------------------------------------------------------------------------|
| bibliothèque    | Code pré-exis,ant permettant de régler un problème, ou                          |
|                 | permettant d'implémenter certaines fonctionnalités. Ce code                     |
|                 | est conçu pour être réutilisable entre plusieurs applications                   |
|-----------------+---------------------------------------------------------------------------------|
| environnement   | Un environnement d'execution ou /runtime/ en anglais est un                     |
| d'execution     | programme qui fournit certaines fonctionnalités à un autre                      |
|                 | programme pour être éxecuté. Dans le cas qui nous interesse                     |
|                 | pendant ce document, l'environnement d'execution permet                         |
|                 | spécifiquement de faire fonctionner du code asynchrone                          |
|                 | en ~Python~.                                                                    |
|-----------------+---------------------------------------------------------------------------------|
| Plugin          | Un plugin est un partie optionnelle d'un programme                              |
|                 | qui peut-être branché à un programme principale pour ajouter                    |
|                 | des fonctionnalités. On parle également d'"architecture plugins"                |
|                 | pour parler des architectures logicielles qui simplifie la                      |
|                 | création de nouvelles fonctionnalités interchangeables dans.                    |
|                 | un programme                                                                    |
|-----------------+---------------------------------------------------------------------------------|
| Emulateur       | Un émulateur est un programme qui se comporte comme une machine                 |
|                 | particulière. Nous utiliserons notamment un émulateur                           |
|                 | Android pour faire fonctionner notre programme comme si                         |
|                 | il fonctionnait sur Android                                                     |
|-----------------+---------------------------------------------------------------------------------|
| Saas            | Sigle anglais signifiant /Software as a Service/ c'est un type                  |
|                 | de programme qui n'est pas installé sur la machine d'un                         |
|                 | utilisateur mais qui fonctionne de façon distante.                              |
|-----------------+---------------------------------------------------------------------------------|
| Serveur virtuel | Un serveur virtuel est une instance de serveur qui fonctionne sur un système    |
|                 | d'exploitation hôte en partageant ses ressources matérielles.                   |
|                 | Des logiciels appelés /hyperviseurs/ permettent de faire fonctionner            |
|                 | plusieurs serveurs virtuels sur la même machine physique.                       |
|-----------------+---------------------------------------------------------------------------------|
| Container       | Un container est un environnement isolé du reste du système                     |
|                 | d'exploitation. Un container permet de garantir qu'un                           |
|                 | programme fonctionnera de la même façon quelque soit le système                 |
|                 | d'exploitation qui fait fonctionner le container.                               |
|                 | Un container /Docker/ est quant a lui un type spéciale de                       |
|                 | container qui utilise le programme /Docker/ pour rendre                         |
|                 | ce container réutilisable entre plusieurs installations                         |
|                 | à l'aide d'un fichier de configuration appelé /Dockerfile/                      |
|-----------------+---------------------------------------------------------------------------------|
| Cache           | Le cache est une mémoire tampon qui est utilisée en informatique pour           |
|                 | éviter de refaire un calcul ou de récupérer des données identiques plusieurs    |
|                 | fois.                                                                           |
|-----------------+---------------------------------------------------------------------------------|
| Interface       | Dans le contexte de la programmation orientée objet, une interface est un       |
|                 | élement d'architecture qui permet de définir les contrats que doit              |
|                 | suivre un classe pour pouvoir implémenter l'interface.                          |
|                 | Le but est généralement de créer des programmes modulaires dans lesquels        |
|                 | plusieurs implémentation d'une interface existent. Par exemple, on peut définir |
|                 | une interface "Séquence" qui comprends les méthodes "longueur" et "estVide".    |
|                 | Les implémentations de cette interface devront toutes implémenter ces deux      |
|                 | méthodes.                                                                       |
|-----------------+---------------------------------------------------------------------------------|
| type            | Un type défini des caractéristiques inhérentes à certains élements dans un      |
|                 | programme. La notion de type peut être considéré comme une généralisation       |
|                 | de la notion d'interface aux interfaces elles mêmes et aux types                |
|                 | primitifs d'un langage.                                                         |
|-----------------+---------------------------------------------------------------------------------|
| implémentation  | Dans un contexte orienté objet, on parle de l'implémentation d'une interface.   |
|                 | Une implémentation est une classe qui implémente les méthodes d'une interface   |
|                 | donnée.                                                                         |
|-----------------+---------------------------------------------------------------------------------|
| design pattern  | Un /design pattern/ est une collection de classes agencée de façon précises     |
|                 | entre elles dans le but de répondre à un problème connu et documenté.           |
|                 | On dit que les design patterns ne sont pas inventé mais découverts.             |
